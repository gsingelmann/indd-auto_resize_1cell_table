#targetengine "gs_temp"main();function main() {	try {		app.removeEventListener( "afterSelectionAttributeChanged", resize_cell );		app.addEventListener( "afterSelectionAttributeChanged", resize_cell );	} catch(e) {		if (dbg) $.writeln( "after attribute error " + e );	}}function resize_cell( e ) {	var lw = e.target;	if ( lw.constructor.name == "LayoutWindow" ) {		if ( lw.selection.length && lw.selection[0].constructor.name == "TextFrame" ) {			try {				var t = lw.selection[0];				var s = t.parentStory;				if ( s.paragraphs.length == 1 && s.tables.length == 1 && s.tables[0].cells.length == 1) {					var sz = get_size( t );					if ( sz.w && sz.h ) {						s.tables[0].cells[0].width = sz.w-.5;									s.tables[0].cells[0].height = sz.h-.5;					} else {					}				} else {				}			} catch(err) {				for ( var p in err ) {					if ( p != "source" ) $.writeln( p + ": " + err[p] );				}			}		}	} else {	}	function get_size( item ) {		var 			cs = CoordinateSpaces.SPREAD_COORDINATES,			tl = item.resolve( AnchorPoint.TOP_LEFT_ANCHOR, cs ),			bl = item.resolve( AnchorPoint.BOTTOM_LEFT_ANCHOR, cs ),			tr = item.resolve( AnchorPoint.TOP_RIGHT_ANCHOR, cs ),			br = item.resolve( AnchorPoint.BOTTOM_RIGHT_ANCHOR, cs );					var			tvo = item.transformValuesOf( cs ),			ccra = tvo[0].counterclockwiseRotationAngle,			csa = tvo[0].clockwiseShearAngle,						// Einfacher Pythagoras hier			top_edge = get_dist( tl[0], tr[0] ),			left_edge = get_dist( tl[0], bl[0] );					var			// Weder Drehung noch Scherung ändert was an der Länge der Oberkante			effw = top_edge,						// Die länge der linken Kante wird durch eine Scherung verlängert zur Hypothenuse 			// des Dreiecks, wo die Ankathete die eigentliche Länge ist.			effh = csa ? left_edge * Math.cos( deg2rad( csa ) ) : left_edge,						// .resolve liefert Punkt. Also geb ich UnitValues zurück			ewuv = new UnitValue( effw, "pt"),			ehuv = new UnitValue( effh, "pt"),						// So rechnet man ein UnitValue in skalare Millimeterangaben um.			ewmm = ewuv.as('mm'),			ehmm = ehuv.as('mm');	 		return { w: ewmm, h: ehmm, tl: tl[0] }	 		function get_dist( p1, p2 ) {			return Math.sqrt( Math.pow ( p2[1]-p1[1], 2 ) + Math.pow( p2[0]-p1[0], 2 ) );		}		function deg2rad( x ) {			x = x % 360;			if ( x < 0 ) x = 360 + x;			return x * ( 2 * Math.PI ) / 360;		}	}	function r2( n ) {		return Math.round( n * 100 ) / 100;	}}